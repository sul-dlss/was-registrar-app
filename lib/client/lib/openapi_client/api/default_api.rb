=begin
#WASAPI Export API as implemented by Archive-It

#WASAPI Export API.  What Archive-It has implemented. 

The version of the OpenAPI document: 1.0.0

Generated by: https://openapi-generator.tech
OpenAPI Generator version: 4.1.0

=end

require 'cgi'

module OpenapiClient
  class DefaultApi
    attr_accessor :api_client

    def initialize(api_client = ApiClient.default)
      @api_client = api_client
    end
    # What jobs do I have?
    # Show the jobs on this server accessible to the client
    # @param [Hash] opts the optional parameters
    # @option opts [Integer] :page One-based index for pagination 
    # @return [InlineResponse200]
    def jobs_get(opts = {})
      data, _status_code, _headers = jobs_get_with_http_info(opts)
      data
    end

    # What jobs do I have?
    # Show the jobs on this server accessible to the client
    # @param [Hash] opts the optional parameters
    # @option opts [Integer] :page One-based index for pagination 
    # @return [Array<(InlineResponse200, Integer, Hash)>] InlineResponse200 data, response status code and response headers
    def jobs_get_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.jobs_get ...'
      end
      # resource path
      local_var_path = '/jobs'

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'page'] = opts[:'page'] if !opts[:'page'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:body] 

      # return_type
      return_type = opts[:return_type] || 'InlineResponse200' 

      # auth_names
      auth_names = opts[:auth_names] || []

      new_options = opts.merge(
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#jobs_get\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # How is my job doing?
    # Retrieve information about a job, both the parameters of its submission and its current state.  If the job is complete, the client can get the result through a separate request to `jobs/{jobtoken}/result`.
    # @param jobtoken [String] The job token returned from previous request
    # @param [Hash] opts the optional parameters
    # @return [Job]
    def jobs_jobtoken_get(jobtoken, opts = {})
      data, _status_code, _headers = jobs_jobtoken_get_with_http_info(jobtoken, opts)
      data
    end

    # How is my job doing?
    # Retrieve information about a job, both the parameters of its submission and its current state.  If the job is complete, the client can get the result through a separate request to &#x60;jobs/{jobtoken}/result&#x60;.
    # @param jobtoken [String] The job token returned from previous request
    # @param [Hash] opts the optional parameters
    # @return [Array<(Job, Integer, Hash)>] Job data, response status code and response headers
    def jobs_jobtoken_get_with_http_info(jobtoken, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.jobs_jobtoken_get ...'
      end
      # verify the required parameter 'jobtoken' is set
      if @api_client.config.client_side_validation && jobtoken.nil?
        fail ArgumentError, "Missing the required parameter 'jobtoken' when calling DefaultApi.jobs_jobtoken_get"
      end
      # resource path
      local_var_path = '/jobs/{jobtoken}'.sub('{' + 'jobtoken' + '}', CGI.escape(jobtoken.to_s).gsub('%2F', '/'))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:body] 

      # return_type
      return_type = opts[:return_type] || 'Job' 

      # auth_names
      auth_names = opts[:auth_names] || []

      new_options = opts.merge(
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#jobs_jobtoken_get\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # What is the result of my job?
    # For a complete job, produces a page of the resulting files. 
    # @param jobtoken [String] The job token returned from previous request
    # @param [Hash] opts the optional parameters
    # @option opts [Integer] :page One-based index for pagination 
    # @return [FileSet]
    def jobs_jobtoken_result_get(jobtoken, opts = {})
      data, _status_code, _headers = jobs_jobtoken_result_get_with_http_info(jobtoken, opts)
      data
    end

    # What is the result of my job?
    # For a complete job, produces a page of the resulting files. 
    # @param jobtoken [String] The job token returned from previous request
    # @param [Hash] opts the optional parameters
    # @option opts [Integer] :page One-based index for pagination 
    # @return [Array<(FileSet, Integer, Hash)>] FileSet data, response status code and response headers
    def jobs_jobtoken_result_get_with_http_info(jobtoken, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.jobs_jobtoken_result_get ...'
      end
      # verify the required parameter 'jobtoken' is set
      if @api_client.config.client_side_validation && jobtoken.nil?
        fail ArgumentError, "Missing the required parameter 'jobtoken' when calling DefaultApi.jobs_jobtoken_result_get"
      end
      # resource path
      local_var_path = '/jobs/{jobtoken}/result'.sub('{' + 'jobtoken' + '}', CGI.escape(jobtoken.to_s).gsub('%2F', '/'))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'page'] = opts[:'page'] if !opts[:'page'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:body] 

      # return_type
      return_type = opts[:return_type] || 'FileSet' 

      # auth_names
      auth_names = opts[:auth_names] || []

      new_options = opts.merge(
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#jobs_jobtoken_result_get\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Make a new job
    # Create a job to perform some task
    # @param unknown_base_type [UNKNOWN_BASE_TYPE] 
    # @param [Hash] opts the optional parameters
    # @return [Job]
    def jobs_post(unknown_base_type, opts = {})
      data, _status_code, _headers = jobs_post_with_http_info(unknown_base_type, opts)
      data
    end

    # Make a new job
    # Create a job to perform some task
    # @param unknown_base_type [UNKNOWN_BASE_TYPE] 
    # @param [Hash] opts the optional parameters
    # @return [Array<(Job, Integer, Hash)>] Job data, response status code and response headers
    def jobs_post_with_http_info(unknown_base_type, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.jobs_post ...'
      end
      # verify the required parameter 'unknown_base_type' is set
      if @api_client.config.client_side_validation && unknown_base_type.nil?
        fail ArgumentError, "Missing the required parameter 'unknown_base_type' when calling DefaultApi.jobs_post"
      end
      # resource path
      local_var_path = '/jobs'

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:body] || @api_client.object_to_http_body(unknown_base_type) 

      # return_type
      return_type = opts[:return_type] || 'Job' 

      # auth_names
      auth_names = opts[:auth_names] || []

      new_options = opts.merge(
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#jobs_post\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Get the archive files I need
    # Produces a page of the list of the files accessible to the client matching all of the parameters.  A parameter with multiple options matches when any option matches; a missing parameter implicitly matches. 
    # @param [Hash] opts the optional parameters
    # @option opts [Integer] :page One-based index for pagination 
    # @option opts [String] :filename A string exactly matching the webdata file&#39;s basename (ie must match the beginning and end of the filename, not the full path of directories). 
    # @option opts [DateTime] :crawl_time_after Match resources that were crawled at or after the time given according to RFC3339.  A date given with no time of day means midnight.  Coordinated Universal (UTC) is preferrred and assumed if no timezone is included. Because &#x60;crawl-time-after&#x60; matches equal time stamps while &#x60;crawl-time-before&#x60; excludes equal time stamps, and because we specify instants rather than durations implicit from our units, we can smoothly scale between days and seconds.  That is, we specify ranges in the manner of the C programming language, eg low ≤ x &lt; high.  For example, matching the month of November of 2016 is specified by &#x60;crawl-time-after&#x3D;2016-11 &amp; crawl-time-before&#x3D;2016-12&#x60; or equivalently by &#x60;crawl-time-after&#x3D;2016-11-01T00:00:00Z &amp; crawl-time-before&#x3D;2016-11-30T16:00:00-08:00&#x60;. 
    # @option opts [DateTime] :crawl_time_before Match resources that were crawled strictly before the time given according to RFC3339.  See more detail at &#x60;crawl-time-after&#x60;. 
    # @option opts [DateTime] :crawl_start_after Match resources that were crawled in a job that started at or after the time given according to RFC3339.  (Note that the original content of a file could be crawled many days after the crawl job started; would you prefer &#x60;crawl-time-after&#x60; / &#x60;crawl-time-before&#x60;?) 
    # @option opts [DateTime] :crawl_start_before Match resources that were crawled in a job that started strictly before the time given according to RFC3339.  See more detail at &#x60;crawl-start-after&#x60;. 
    # @option opts [Integer] :collection The numeric ID of one or more collections, given as separate fields. For only this parameter, WASAPI accepts multiple values and will match items in any of the specified collections.  For example, matching the items from two collections can be specified by &#x60;collection&#x3D;1 &amp; collection&#x3D;2&#x60;. 
    # @option opts [Integer] :crawl The numeric ID of the crawl 
    # @return [FileSet]
    def webdata_get(opts = {})
      data, _status_code, _headers = webdata_get_with_http_info(opts)
      data
    end

    # Get the archive files I need
    # Produces a page of the list of the files accessible to the client matching all of the parameters.  A parameter with multiple options matches when any option matches; a missing parameter implicitly matches. 
    # @param [Hash] opts the optional parameters
    # @option opts [Integer] :page One-based index for pagination 
    # @option opts [String] :filename A string exactly matching the webdata file&#39;s basename (ie must match the beginning and end of the filename, not the full path of directories). 
    # @option opts [DateTime] :crawl_time_after Match resources that were crawled at or after the time given according to RFC3339.  A date given with no time of day means midnight.  Coordinated Universal (UTC) is preferrred and assumed if no timezone is included. Because &#x60;crawl-time-after&#x60; matches equal time stamps while &#x60;crawl-time-before&#x60; excludes equal time stamps, and because we specify instants rather than durations implicit from our units, we can smoothly scale between days and seconds.  That is, we specify ranges in the manner of the C programming language, eg low ≤ x &lt; high.  For example, matching the month of November of 2016 is specified by &#x60;crawl-time-after&#x3D;2016-11 &amp; crawl-time-before&#x3D;2016-12&#x60; or equivalently by &#x60;crawl-time-after&#x3D;2016-11-01T00:00:00Z &amp; crawl-time-before&#x3D;2016-11-30T16:00:00-08:00&#x60;. 
    # @option opts [DateTime] :crawl_time_before Match resources that were crawled strictly before the time given according to RFC3339.  See more detail at &#x60;crawl-time-after&#x60;. 
    # @option opts [DateTime] :crawl_start_after Match resources that were crawled in a job that started at or after the time given according to RFC3339.  (Note that the original content of a file could be crawled many days after the crawl job started; would you prefer &#x60;crawl-time-after&#x60; / &#x60;crawl-time-before&#x60;?) 
    # @option opts [DateTime] :crawl_start_before Match resources that were crawled in a job that started strictly before the time given according to RFC3339.  See more detail at &#x60;crawl-start-after&#x60;. 
    # @option opts [Integer] :collection The numeric ID of one or more collections, given as separate fields. For only this parameter, WASAPI accepts multiple values and will match items in any of the specified collections.  For example, matching the items from two collections can be specified by &#x60;collection&#x3D;1 &amp; collection&#x3D;2&#x60;. 
    # @option opts [Integer] :crawl The numeric ID of the crawl 
    # @return [Array<(FileSet, Integer, Hash)>] FileSet data, response status code and response headers
    def webdata_get_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.webdata_get ...'
      end
      # resource path
      local_var_path = '/webdata'

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'page'] = opts[:'page'] if !opts[:'page'].nil?
      query_params[:'filename'] = opts[:'filename'] if !opts[:'filename'].nil?
      query_params[:'crawl-time-after'] = opts[:'crawl_time_after'] if !opts[:'crawl_time_after'].nil?
      query_params[:'crawl-time-before'] = opts[:'crawl_time_before'] if !opts[:'crawl_time_before'].nil?
      query_params[:'crawl-start-after'] = opts[:'crawl_start_after'] if !opts[:'crawl_start_after'].nil?
      query_params[:'crawl-start-before'] = opts[:'crawl_start_before'] if !opts[:'crawl_start_before'].nil?
      query_params[:'collection'] = opts[:'collection'] if !opts[:'collection'].nil?
      query_params[:'crawl'] = opts[:'crawl'] if !opts[:'crawl'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:body] 

      # return_type
      return_type = opts[:return_type] || 'FileSet' 

      # auth_names
      auth_names = opts[:auth_names] || []

      new_options = opts.merge(
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#webdata_get\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
  end
end
